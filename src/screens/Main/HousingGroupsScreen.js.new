import React, { useState, useEffect, useCallback, useRef } from 'react';
import { 
  View, 
  Text, 
  FlatList, 
  RefreshControl,
  ActivityIndicator,
  StyleSheet, 
  Animated,
  Dimensions
} from 'react-native';
import { useFocusEffect } from '@react-navigation/native';
import ActionButton from '../../components/common/ActionButton';
import AppHeader from '../../components/layout/AppHeader';
import { Ionicons } from '@expo/vector-icons';
import { supabase } from '../../lib/supabaseClient';
import { COLORS, FONTS } from '../../constants/theme';
import SearchComponent from '../../components/common/SearchComponent';
import HousingGroupCard from '../../components/cards/HousingGroupCard';

const { width } = Dimensions.get('window');
const CARD_MARGIN = 10;

const HousingGroupsScreen = ({ navigation }) => {
  // State management
  const [housingGroups, setHousingGroups] = useState([]);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [searchTerm, setSearchTerm] = useState('');
  const [viewMode, setViewMode] = useState('List');
  const [userId, setUserId] = useState(null);
  
  // Animation values for the ActionButton
  const fadeAnim = useRef(new Animated.Value(1)).current;
  const scrollY = useRef(new Animated.Value(0)).current;
  const [isScrolling, setIsScrolling] = useState(false);
  const scrollEndTimer = useRef(null);

  // Fetch user ID on component mount
  useEffect(() => {
    const fetchUserId = async () => {
      const { data: { user } } = await supabase.auth.getUser();
      if (user) {
        setUserId(user.id);
      }
    };
    fetchUserId();
  }, []);

  // Fetch housing groups data from Supabase
  const fetchHousingGroups = useCallback(async (isRefreshing = false) => {
    if (isRefreshing) {
      setRefreshing(true);
    } else if (!refreshing) {
      setLoading(true);
    }

    try {
      // First, get the current user
      const { data: { user }, error: userError } = await supabase.auth.getUser();
      if (userError || !user) throw userError || new Error('No authenticated user');

      // Fetch all active housing groups
      const { data: groups, error: groupsError } = await supabase
        .from('housing_groups')
        .select('*')
        .eq('is_active', true)
        .order('created_at', { ascending: false });

      if (groupsError) throw groupsError;

      // For each group, check user's membership status
      const groupsWithStatus = await Promise.all(groups.map(async (group) => {
        // Get member count for the group
        const { count: memberCount } = await supabase
          .from('housing_group_members')
          .select('*', { count: 'exact', head: true })
          .eq('group_id', group.id)
          .eq('status', 'approved');

        // Check if user is a member of this group
        const { data: membership, error: membershipError } = await supabase
          .from('housing_group_members')
          .select('status')
          .eq('group_id', group.id)
          .eq('user_id', user.id)
          .single();

        // Check if user has applied to the related housing listing
        let applicationStatus = null;
        if (group.listing_id) {
          const { data: application, error: appError } = await supabase
            .from('housing_applications')
            .select('status')
            .eq('user_id', user.id)
            .eq('listing_id', group.listing_id)
            .single();
          
          if (!appError && application) {
            applicationStatus = application.status;
          }
        }

        return {
          ...group,
          memberCount: memberCount || 0,
          membershipStatus: membership?.status || null,
          applicationStatus
        };
      }));

      setHousingGroups(groupsWithStatus);
    } catch (error) {
      console.error('Error fetching housing groups:', error);
      // We could show an error message to the user here
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  }, [refreshing]);

  // Initial data fetch and refresh on focus
  useEffect(() => {
    fetchHousingGroups();
  }, [fetchHousingGroups]);

  useFocusEffect(
    useCallback(() => {
      fetchHousingGroups();
    }, [])
  );

  // Handle pull-to-refresh
  const onRefresh = useCallback(() => {
    fetchHousingGroups(true);
  }, [fetchHousingGroups]);

  // Filter groups based on search term
  const filteredGroups = housingGroups.filter(group => 
    group.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
    (group.description && group.description.toLowerCase().includes(searchTerm.toLowerCase()))
  );

  // Handle join group action
  const handleJoinGroup = async (groupId) => {
    try {
      if (!userId) {
        throw new Error('User not authenticated');
      }

      const { data, error } = await supabase
        .from('housing_group_members')
        .insert([
          { 
            group_id: groupId, 
            user_id: userId,
            status: 'pending',
            join_date: new Date().toISOString()
          }
        ]);

      if (error) throw error;

      // Refresh the groups list to update status
      fetchHousingGroups();
    } catch (error) {
      console.error('Error joining group:', error);
      // Show error to user
      alert('Failed to join group. Please try again.');
    }
  };

  // Handle leave group action
  const handleLeaveGroup = async (groupId) => {
    try {
      if (!userId) {
        throw new Error('User not authenticated');
      }

      const { error } = await supabase
        .from('housing_group_members')
        .delete()
        .eq('group_id', groupId)
        .eq('user_id', userId);

      if (error) throw error;

      // Refresh the groups list to update status
      fetchHousingGroups();
    } catch (error) {
      console.error('Error leaving group:', error);
      // Show error to user
      alert('Failed to leave group. Please try again.');
    }
  };

  // Handle card action based on membership status
  const handleCardAction = (item) => {
    if (item.membershipStatus === 'approved') {
      handleLeaveGroup(item.id);
    } else if (!item.membershipStatus) {
      handleJoinGroup(item.id);
    }
  };

  // Render item for FlatList
  const renderHousingGroup = ({ item }) => (
    <HousingGroupCard 
      item={item}
      onPress={() => navigation.navigate('HousingGroupDetail', { groupId: item.id })}
      onActionPress={() => handleCardAction(item)}
      gridMode={viewMode === 'Grid'}
    />
  );

  // Render loading state
  if (loading && !refreshing) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={COLORS.primary} />
      </View>
    );
  }

  // Render empty state
  if (!loading && filteredGroups.length === 0) {
    return (
      <View style={styles.container}>
        <AppHeader title="Housing Groups" navigation={navigation} canGoBack={true} />
        <SearchComponent
          searchTerm={searchTerm}
          onSearchChange={setSearchTerm}
          selectedCategory="Housing Groups"
          onCategoryChange={() => {}}
          viewMode={viewMode}
          onViewModeChange={setViewMode}
          viewModes={['Grid', 'List']}
        />
        <View style={styles.emptyContainer}>
          <Ionicons name="people-outline" size={64} color="#ccc" />
          <Text style={styles.emptyTitle}>No Housing Groups Found</Text>
          <Text style={styles.emptyText}>
            {searchTerm ? 'Try a different search term' : 'Check back later for new housing groups'}
          </Text>
        </View>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      {/* Floating Action Button with fade animation */}
      <Animated.View style={[styles.floatingActionButton, { opacity: fadeAnim }]}>
        <ActionButton
          onPress={() => navigation.navigate('CreateHousingGroup')}
          iconName="add"
          color="#007AFF"
          size={56}
        />
      </Animated.View>
      
      <AppHeader title="Housing Groups" navigation={navigation} canGoBack={true} />
      
      {/* Search and filter */}
      <SearchComponent
        searchTerm={searchTerm}
        onSearchChange={setSearchTerm}
        selectedCategory="Housing Groups"
        onCategoryChange={() => {}}
        viewMode={viewMode}
        onViewModeChange={setViewMode}
        viewModes={['Grid', 'List']}
        contentType="housing_groups"
      />
      
      {/* Listing count */}
      <Text style={styles.listingCount}>{filteredGroups.length} {filteredGroups.length === 1 ? 'Group' : 'Groups'}</Text>
      
      {/* Housing groups list */}
      <Animated.FlatList
        data={filteredGroups}
        renderItem={renderHousingGroup}
        keyExtractor={item => item.id}
        contentContainerStyle={styles.listContent}
        numColumns={viewMode === 'Grid' ? 2 : 1}
        key={viewMode} // Force re-render when changing view mode
        showsVerticalScrollIndicator={false}
        refreshControl={
          <RefreshControl refreshing={refreshing} onRefresh={onRefresh} />
        }
        onScroll={Animated.event(
          [{ nativeEvent: { contentOffset: { y: scrollY } } }],
          { 
            useNativeDriver: true,
            listener: () => {
              // Clear any existing timer
              if (scrollEndTimer.current) {
                clearTimeout(scrollEndTimer.current);
              }
              
              // If not already scrolling, animate button fade out
              if (!isScrolling) {
                setIsScrolling(true);
                Animated.timing(fadeAnim, {
                  toValue: 0,
                  duration: 200,
                  useNativeDriver: true,
                }).start();
              }
              
              // Set a timer to detect when scrolling stops
              scrollEndTimer.current = setTimeout(() => {
                setIsScrolling(false);
                Animated.timing(fadeAnim, {
                  toValue: 1,
                  duration: 500, // Slower fade in
                  useNativeDriver: true,
                }).start();
              }, 200);
            }
          }
        )}
        scrollEventThrottle={16}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#FFFFFF',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#FFFFFF',
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  emptyTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginTop: 16,
    color: '#333',
  },
  emptyText: {
    fontSize: 14,
    color: '#666',
    textAlign: 'center',
    marginTop: 8,
  },
  floatingActionButton: {
    position: 'absolute',
    bottom: 20,
    right: 16,
    zIndex: 1000,
  },
  listContent: {
    padding: 12,
    paddingBottom: 90, // Add extra padding at bottom for FAB
  },
  listingCount: {
    fontSize: 14,
    fontWeight: '500',
    color: '#666',
    paddingHorizontal: 16,
    paddingVertical: 8,
    backgroundColor: '#f8f8f8',
  }
});

export default HousingGroupsScreen;
